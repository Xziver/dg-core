# 10 — 当前阶段实现目标

> 本文档定义 dg-engine MVP 阶段的实现范围、技术边界与交付标准。
> 所有开发工作应以本文档为准，不超前、不遗漏。

---

## 1. MVP 定位

### 1.1 目标

构建一个**纯后端世界引擎**，通过 HTTP API 接收结构化事件，执行游戏规则，返回结构化结果。

### 1.2 形态

| 项目 | 说明 |
|------|------|
| 服务类型 | 单进程 FastAPI 后端服务 |
| 通信方式 | HTTP API（REST） |
| 测试方式 | 通过 API 调用（curl / httpx / pytest）验证 |
| 无前端 | MVP 阶段没有 Web UI，没有 Bot 客户端 |
| 无 NLP | 引擎不解析自然语言，只接收结构化 Event |

### 1.3 验收标准

> **MVP 完成 = 可以通过 HTTP API 完成一局简化的游戏流程**

具体而言：
1. 创建 Session，添加玩家
2. 创建 Patient 和 Ghost
3. 发起 CMYK 技能检定，获得骰子结果
4. 执行基本战斗流程（攻击 → 结算 → 伤害）
5. 所有事件记录在 Timeline 中
6. 可查询 Session 状态、Patient 状态、Timeline

---

## 2. MVP 实现范围

### 2.1 必须实现（In Scope）

#### 基础设施层（infra）

| 模块 | 内容 | 文件 |
|------|------|------|
| 配置管理 | `Settings` + `.env` 加载 | `app/infra/config.py` |
| 数据库 | AsyncEngine + AsyncSession 工厂 | `app/infra/db.py` |
| SQLite | 开发和测试使用 SQLite | `data/dg_engine.db` |

#### 数据模型（models）

| Model | 说明 | 文件 |
|-------|------|------|
| `Player` | 玩家账号 | `app/models/player.py` |
| `Session` | 游戏会话 | `app/models/session.py` |
| `SessionPlayer` | 会话-玩家关联 | `app/models/session.py` |
| `Patient` | 褪色症患者 | `app/models/character.py` |
| `Ghost` | 电子幽灵 | `app/models/character.py` |
| `PrintAbility` | 打印能力 | `app/models/ability.py` |
| `TimelineEvent` | 时间线事件 | `app/models/timeline.py` |
| `WorldState` | 世界状态快照 | `app/models/world.py` |
| `ColorFragment` | 颜色碎片 | `app/models/fragment.py` |

#### Alembic 迁移

- 初始化 Alembic
- 生成初始迁移脚本（包含所有表）
- 可执行 `alembic upgrade head` 创建完整 schema

#### Pydantic Schema

| Schema | 说明 | 文件 |
|--------|------|------|
| `EngineEvent` | 引擎输入事件 | `app/models/event.py` |
| `EngineResult` | 引擎输出结果 | `app/models/result.py` |
| `PatientCreate` / `GhostCreate` | 创建请求 | `app/models/schemas.py` |
| `PatientPublicSchema` / `PatientFullSchema` | 数据视图 | `app/models/schemas.py` |
| `CMYKAttributes` / `CMYKAttribute` | 属性结构 | `app/models/schemas.py` |

#### 骰子模块（modules.dice）

| 功能 | 说明 |
|------|------|
| `roll_dice(count, sides)` | 基础骰子投掷 |
| `cmyk_check(color_value, threshold)` | CMYK 技能检定 |
| 骰子结果确定性 | 支持 seed 注入，便于测试 |

```python
# app/modules/dice/roller.py

import random
from dataclasses import dataclass


@dataclass
class DiceResult:
    values: list[int]           # 每个骰子的值
    total: int                  # 总和
    highest: int                # 最高值
    count: int                  # 骰子数量
    sides: int                  # 面数


def roll_dice(count: int, sides: int = 6, rng: random.Random | None = None) -> DiceResult:
    """投掷骰子"""
    r = rng or random.Random()
    values = [r.randint(1, sides) for _ in range(count)]
    return DiceResult(
        values=values,
        total=sum(values),
        highest=max(values) if values else 0,
        count=count,
        sides=sides,
    )


@dataclass
class CheckResult:
    dice: DiceResult
    threshold: int
    passed: bool
    margin: int                 # 成功/失败的差值


def cmyk_check(
    color_value: int,
    threshold: int = 4,
    sides: int = 6,
    rng: random.Random | None = None,
) -> CheckResult:
    """
    CMYK 技能检定。

    规则：投 color_value 个 d6，最高值 >= threshold 则成功。
    """
    dice = roll_dice(count=color_value, sides=sides, rng=rng)
    passed = dice.highest >= threshold
    margin = dice.highest - threshold
    return CheckResult(
        dice=dice,
        threshold=threshold,
        passed=passed,
        margin=margin,
    )
```

#### Domain 层

| 模块 | 功能 | 文件 |
|------|------|------|
| Dispatcher | 事件路由 | `app/domain/dispatcher.py` |
| Session 管理 | 创建/加入/离开 Session | `app/domain/session.py` |
| 角色管理 | Patient/Ghost CRUD | `app/domain/character.py` |
| 技能检定 | CMYK 骰子检定 | `app/domain/rules/skill.py` |
| 基本战斗 | 攻击 → 检定 → 伤害结算 | `app/domain/rules/combat.py` |
| 时间线 | 记录所有事件 | `app/domain/timeline.py` |
| 世界上下文 | 当前 Session 状态管理 | `app/domain/context.py` |

#### API 层

| 端点 | 方法 | 说明 |
|------|------|------|
| `POST /bot/event` | POST | 提交引擎事件 |
| `GET /bot/session/{id}/status` | GET | 查询会话状态 |
| `GET /bot/patient/{id}/public` | GET | 查询患者公开信息 |
| `POST /admin/session` | POST | 创建会话（管理接口） |
| `POST /admin/player` | POST | 注册玩家（管理接口） |
| `POST /admin/patient` | POST | 创建患者（管理接口） |
| `POST /admin/ghost` | POST | 创建幽灵（管理接口） |
| `GET /admin/timeline/{session_id}` | GET | 查询时间线（管理接口） |

#### 启动入口

```python
# app/main.py

from fastapi import FastAPI
from app.api import bot, admin
from app.infra.db import engine
from app.models.base import Base

app = FastAPI(title="dg-engine", version="0.1.0")

app.include_router(bot.router)
app.include_router(admin.router)


@app.on_event("startup")
async def startup():
    # 开发模式：自动建表（生产用 alembic）
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


@app.get("/health")
async def health():
    return {"status": "ok", "engine": "dg-engine", "version": "0.1.0"}
```

### 2.2 MVP 游戏流程验证

以下是完整的 MVP 验证流程，全部通过 HTTP API 调用完成：

```bash
# 1. 健康检查
curl http://localhost:8000/health

# 2. 创建会话
curl -X POST http://localhost:8000/admin/session \
  -H "Content-Type: application/json" \
  -d '{"name": "测试局", "max_players": 4}'

# 3. 注册玩家
curl -X POST http://localhost:8000/admin/player \
  -H "Content-Type: application/json" \
  -d '{"platform": "web", "platform_user_id": "user_001", "display_name": "测试玩家A"}'

# 4. 创建患者
curl -X POST http://localhost:8000/admin/patient \
  -H "Content-Type: application/json" \
  -d '{
    "player_id": "...",
    "name": "李明",
    "base_color": "C",
    "personality_files": {"C": "一段关于忧郁的故事..."},
    "ideal_projection": "希望成为一个能看穿一切的人"
  }'

# 5. 创建幽灵（另一位玩家创造）
curl -X POST http://localhost:8000/admin/ghost \
  -H "Content-Type: application/json" \
  -d '{
    "patient_id": "...",
    "creator_player_id": "...",
    "name": "Echo",
    "base_color": "C",
    "personality": "冷静而偏执的蓝色实体",
    "print_ability": {
      "name": "时间断层",
      "description": "冻结目标周围3秒内的数据流",
      "color": "C",
      "effect_type": "control"
    }
  }'

# 6. 玩家加入会话
curl -X POST http://localhost:8000/bot/event \
  -H "Content-Type: application/json" \
  -d '{
    "event_type": "system.join_session",
    "session_id": "...",
    "player_id": "...",
    "patient_id": "...",
    "payload": {},
    "timestamp": "2025-01-01T00:00:00Z"
  }'

# 7. 发起技能检定
curl -X POST http://localhost:8000/bot/event \
  -H "Content-Type: application/json" \
  -d '{
    "event_type": "action.skill_check",
    "session_id": "...",
    "player_id": "...",
    "patient_id": "...",
    "payload": {
      "skill_color": "C",
      "action_description": "分析墙上的数据流"
    },
    "timestamp": "2025-01-01T00:01:00Z"
  }'

# 8. 查询时间线
curl http://localhost:8000/admin/timeline/sess_001

# 9. 查询患者状态
curl http://localhost:8000/bot/patient/.../public
```

---

## 3. 本阶段不实现（Out of Scope）

### 3.1 明确排除的功能

| 功能 | 原因 | 后续阶段 |
|------|------|---------|
| gRPC 通信 | MVP 仅需 HTTP API | Phase 2（Web 客户端） |
| Web 前端 | MVP 通过 API 调用测试 | Phase 2 |
| Discord / QQ Bot | MVP 无客户端 | Phase 2 |
| NLP 自然语言解析 | 引擎只接收结构化事件 | Phase 2（客户端侧） |
| 异轨系统 | 复杂的叙事修正机制，依赖成熟的 LLM 集成 | Phase 3 |
| 抢夺规则 | 高级通信机制 | Phase 2 |
| 幽体坍缩 | 需要完整的死亡/复活流程 | Phase 2 |
| 扇区选择与穿越 | 需要完整的世界地图系统 | Phase 2 |
| 用户认证/授权 | MVP 假设所有请求可信 | Phase 2 |
| 日志收集/监控 | 基础 `logging` 即可 | Phase 2 |
| Docker 部署 | 本地 `uvicorn` 启动 | Phase 2 |

### 3.2 异轨系统说明

异轨（Off-Rail）系统是电子幽灵的特色机制：当玩家量子活性归零触发幽体坍缩时，
可以通过创作（小说/绘画）来获得系统管理员的特赦。
该系统需要：
- 完善的坍缩判定逻辑
- LLM 辅助评估创作内容
- DM 人工审核流程
- 自定义 Buff 系统

这些都超出 MVP 范围，将在 Phase 3 实现。

---

## 4. LLM / RAG 模块：接口优先

### 4.1 策略

MVP 阶段对 LLM 和 RAG 模块采取**接口优先、Mock 默认**的策略：

| 模块 | MVP 实现 | 可选升级 |
|------|---------|---------|
| `modules.llm.client` | `MockProvider`（返回模板文本） | 配置 `LLM_PROVIDER=openai_compat` 接入真实 LLM |
| `modules.rag.retriever` | `RAG_ENABLED=False`（返回空/预设结果） | 配置 `RAG_ENABLED=True` + ChromaDB |
| Prompt 模板 | 全部编写完成，随时可用 | — |

### 4.2 Mock 行为

```python
# LLM Mock：技能检定叙述
await ask_llm(prompt)
# 返回: "[MOCK] 基于以下 prompt 的模拟输出: ..."

# RAG Mock：知识检索
await query_knowledge(query="灰山城", category="worldview")
# 返回: [RetrievalResult(text="[MOCK] worldview 类别的模拟知识片段", ...)]
```

### 4.3 切换到真实服务

只需修改 `.env` 配置，无需改动任何代码：

```env
# 启用真实 LLM
LLM_PROVIDER=openai_compat
LLM_BASE_URL=https://api.deepseek.com
LLM_API_KEY=sk-xxx
LLM_MODEL=deepseek-chat

# 启用 RAG
RAG_ENABLED=true
RAG_EMBEDDING_PROVIDER=local
RAG_EMBEDDING_MODEL=all-MiniLM-L6-v2
```

---

## 5. 测试策略

### 5.1 测试分层

| 层级 | 范围 | 工具 | 数量目标 |
|------|------|------|---------|
| 单元测试 | 骰子模块、属性计算、数据验证 | pytest | 覆盖核心逻辑 |
| 集成测试 | Domain 层 + DB（内存 SQLite） | pytest + pytest-asyncio | 每个 handler 至少 1 个 |
| E2E 测试 | 完整 API 调用流程 | pytest + httpx (AsyncClient) | MVP 验证流程 |

### 5.2 测试文件结构

```
tests/
├── conftest.py                 # 公共 fixture（db_session, test_client 等）
├── unit/
│   ├── test_dice_roller.py
│   ├── test_cmyk_attributes.py
│   └── test_schemas.py
├── integration/
│   ├── test_session_management.py
│   ├── test_character_crud.py
│   ├── test_skill_check.py
│   └── test_combat_flow.py
└── e2e/
    └── test_mvp_flow.py        # 完整 MVP 游戏流程
```

### 5.3 E2E 测试示例

```python
# tests/e2e/test_mvp_flow.py

import pytest
from httpx import AsyncClient


@pytest.mark.asyncio
async def test_complete_mvp_flow(test_client: AsyncClient):
    """验证 MVP 完整流程"""

    # 1. 创建会话
    resp = await test_client.post("/admin/session", json={
        "name": "MVP 测试局",
        "max_players": 4,
    })
    assert resp.status_code == 200
    session_id = resp.json()["id"]

    # 2. 注册玩家
    resp = await test_client.post("/admin/player", json={
        "platform": "web",
        "platform_user_id": "test_user_001",
        "display_name": "测试玩家",
    })
    assert resp.status_code == 200
    player_id = resp.json()["id"]

    # 3. 创建患者
    resp = await test_client.post("/admin/patient", json={
        "player_id": player_id,
        "name": "李明",
        "base_color": "C",
        "personality_files": {"C": "关于忧郁的故事"},
        "ideal_projection": "看穿一切的人",
    })
    assert resp.status_code == 200
    patient_id = resp.json()["id"]

    # 4. 加入会话
    resp = await test_client.post("/bot/event", json={
        "event_type": "system.join_session",
        "session_id": session_id,
        "player_id": player_id,
        "patient_id": patient_id,
        "payload": {},
        "timestamp": "2025-01-01T00:00:00Z",
    })
    assert resp.status_code == 200
    assert resp.json()["success"] is True

    # 5. 技能检定
    resp = await test_client.post("/bot/event", json={
        "event_type": "action.skill_check",
        "session_id": session_id,
        "player_id": player_id,
        "patient_id": patient_id,
        "payload": {
            "skill_color": "C",
            "action_description": "分析数据流",
        },
        "timestamp": "2025-01-01T00:01:00Z",
    })
    assert resp.status_code == 200
    result = resp.json()
    assert result["success"] is True
    assert "dice_values" in result["data"]
    assert result["sequence"] > 0

    # 6. 查询时间线
    resp = await test_client.get(f"/admin/timeline/{session_id}")
    assert resp.status_code == 200
    events = resp.json()
    assert len(events) >= 2  # join + skill_check
```

---

## 6. 开发顺序

建议按以下顺序实现 MVP：

```
Phase 0: 项目脚手架
├── 目录结构
├── requirements.txt / pyproject.toml
├── .env.example
└── app/main.py (最简 FastAPI 启动)

Phase 1: 基础设施
├── app/infra/config.py
├── app/infra/db.py
├── app/models/base.py
└── Alembic 初始化

Phase 2: 数据模型
├── 所有 ORM Model
├── 初始迁移脚本
├── Pydantic Schema (event / result / schemas)
└── 单元测试

Phase 3: 核心模块
├── modules/dice/roller.py
├── modules/llm/client.py (MockProvider)
├── modules/rag/retriever.py (Mock)
└── 单元测试

Phase 4: Domain 层
├── domain/dispatcher.py
├── domain/session.py
├── domain/character.py
├── domain/rules/skill.py
├── domain/rules/combat.py
├── domain/timeline.py
└── 集成测试

Phase 5: API 层
├── api/bot.py
├── api/admin.py
└── E2E 测试

Phase 6: 验收
└── 完整 MVP 流程测试通过
```

---

## 7. 技术约束总结

| 约束 | 说明 |
|------|------|
| Python 3.11+ | 使用 `type | None` 语法 |
| FastAPI | 异步框架 |
| SQLAlchemy 2.0 | `Mapped` 声明式 + `AsyncSession` |
| Alembic | 数据库迁移 |
| Pydantic v2 | 数据验证 |
| SQLite (Dev) | `aiosqlite` 驱动 |
| PostgreSQL (Prod) | `asyncpg` 驱动 |
| ChromaDB | RAG 向量存储（MVP 可 Mock） |
| pytest + pytest-asyncio | 测试框架 |
| httpx | 异步 HTTP 客户端（测试用） |
