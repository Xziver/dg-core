# 03 — 数据库实现规范

> 本文档定义 dg-engine 的数据库技术选型、ORM 规范、核心表设计与连接管理策略。

---

## 1. 技术选型

| 组件 | 选型 | 说明 |
|------|------|------|
| ORM | SQLAlchemy 2.0（async） | 使用 `AsyncSession` + `Mapped` 声明式映射 |
| 迁移 | Alembic | 版本化管理数据库 schema 变更 |
| Dev 数据库 | SQLite（aiosqlite） | 本地开发与测试，零配置 |
| Prod 数据库 | PostgreSQL（asyncpg） | 生产环境，支持并发与高级特性 |

---

## 2. 项目结构

```
dg-engine/
├── app/
│   ├── infra/
│   │   ├── db.py              # 引擎初始化、session 工厂、连接池配置
│   │   └── config.py          # 数据库连接字符串等配置
│   └── models/
│       ├── __init__.py        # 导出 Base 和所有 Model
│       ├── base.py            # DeclarativeBase 定义
│       ├── player.py          # Player 模型
│       ├── session.py         # Session / SessionPlayer 模型
│       ├── character.py       # Patient / Ghost 模型
│       ├── ability.py         # PrintAbility 模型
│       ├── timeline.py        # TimelineEvent 模型
│       ├── world.py           # WorldState 模型
│       └── fragment.py        # ColorFragment 模型
├── migrations/
│   ├── env.py
│   ├── script.py.mako
│   └── versions/
└── alembic.ini
```

---

## 3. 基础设施层

### 3.1 Database Engine & Session

```python
# app/infra/db.py

from sqlalchemy.ext.asyncio import (
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from app.infra.config import settings

# 创建异步引擎
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DB_ECHO,           # 开发时 True，生产时 False
    pool_pre_ping=True,              # 连接健康检查
    pool_size=settings.DB_POOL_SIZE,
    max_overflow=settings.DB_MAX_OVERFLOW,
)

# Session 工厂
async_session_factory = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


async def get_db() -> AsyncSession:
    """FastAPI 依赖注入：获取数据库 Session"""
    async with async_session_factory() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()
```

### 3.2 配置项

```python
# app/infra/config.py（数据库相关字段）

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    # 数据库
    DATABASE_URL: str = "sqlite+aiosqlite:///data/dg_engine.db"
    DB_ECHO: bool = False
    DB_POOL_SIZE: int = 5         # SQLite 忽略此项
    DB_MAX_OVERFLOW: int = 10     # SQLite 忽略此项

    class Config:
        env_file = ".env"
```

### 3.3 连接池配置说明

| 环境 | DATABASE_URL 示例 | 连接池 |
|------|------------------|--------|
| 开发 | `sqlite+aiosqlite:///data/dg_engine.db` | SQLite 不支持连接池，`pool_size` 被忽略 |
| 测试 | `sqlite+aiosqlite:///:memory:` | 内存数据库，每次测试独立 |
| 生产 | `postgresql+asyncpg://user:pass@host:5432/dg_engine` | `pool_size=5`, `max_overflow=10` |

---

## 4. ORM Base 定义

```python
# app/models/base.py

import uuid
from datetime import datetime, timezone
from sqlalchemy import DateTime, func
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
    """所有 Model 的基类"""
    pass


class TimestampMixin:
    """通用时间戳 Mixin"""
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )


def generate_uuid() -> str:
    return uuid.uuid4().hex
```

---

## 5. 核心表设计

### 5.1 ER 关系概览

```
Player (1) ──── (N) SessionPlayer (N) ──── (1) Session
   │                                           │
   │ (1:N)                                     │ (1:N)
   ▼                                           ▼
Patient (1) ──── (1) Ghost               TimelineEvent
   │                   │                       │
   │ (1:N)             │ (1:N)                 │
   ▼                   ▼                       │
PrintAbility     PrintAbility              WorldState
                                               │
ColorFragment ◄────────────────────────────────┘
```

### 5.2 players —— 玩家账号

```python
# app/models/player.py

from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.models.base import Base, TimestampMixin, generate_uuid


class Player(Base, TimestampMixin):
    """玩家账号层 —— 关联平台身份"""
    __tablename__ = "players"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    platform: Mapped[str] = mapped_column(
        String(32), nullable=False, comment="平台标识: discord / qq / web"
    )
    platform_user_id: Mapped[str] = mapped_column(
        String(128), nullable=False, comment="平台用户 ID"
    )
    display_name: Mapped[str] = mapped_column(
        String(64), nullable=False, comment="显示名称"
    )

    # 关系
    patients: Mapped[list["Patient"]] = relationship(back_populates="player")
    session_players: Mapped[list["SessionPlayer"]] = relationship(back_populates="player")

    __table_args__ = (
        # 同一平台下用户唯一
        {"comment": "玩家账号表"},
    )
```

### 5.3 sessions —— 游戏会话

```python
# app/models/session.py

from sqlalchemy import String, Integer, Enum as SAEnum
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.models.base import Base, TimestampMixin, generate_uuid
import enum


class SessionStatus(str, enum.Enum):
    PREPARING = "preparing"      # 准备中
    ACTIVE = "active"            # 进行中
    PAUSED = "paused"            # 暂停
    COMPLETED = "completed"      # 已完成
    ARCHIVED = "archived"        # 已归档


class Session(Base, TimestampMixin):
    """游戏会话 —— 一局游戏的顶层容器"""
    __tablename__ = "sessions"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    name: Mapped[str] = mapped_column(
        String(128), nullable=False, comment="会话名称"
    )
    status: Mapped[SessionStatus] = mapped_column(
        SAEnum(SessionStatus), default=SessionStatus.PREPARING, nullable=False
    )
    current_chapter: Mapped[int] = mapped_column(
        Integer, default=1, nullable=False, comment="当前章节（扇区）"
    )
    max_players: Mapped[int] = mapped_column(
        Integer, default=8, nullable=False, comment="最大玩家数"
    )

    # 关系
    session_players: Mapped[list["SessionPlayer"]] = relationship(back_populates="session")
    timeline_events: Mapped[list["TimelineEvent"]] = relationship(back_populates="session")
    world_states: Mapped[list["WorldState"]] = relationship(back_populates="session")

    __table_args__ = ({"comment": "游戏会话表"},)
```

### 5.4 session_players —— 会话玩家关联

```python
# app/models/session.py（续）

from sqlalchemy import ForeignKey


class SessionPlayer(Base, TimestampMixin):
    """玩家与会话的多对多关联"""
    __tablename__ = "session_players"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    session_id: Mapped[str] = mapped_column(
        ForeignKey("sessions.id"), nullable=False
    )
    player_id: Mapped[str] = mapped_column(
        ForeignKey("players.id"), nullable=False
    )
    patient_id: Mapped[str] = mapped_column(
        ForeignKey("patients.id"), nullable=True, comment="该玩家在此会话中的患者角色"
    )
    role: Mapped[str] = mapped_column(
        String(16), default="player", nullable=False, comment="角色: player / dm / spectator"
    )

    # 关系
    session: Mapped["Session"] = relationship(back_populates="session_players")
    player: Mapped["Player"] = relationship(back_populates="session_players")

    __table_args__ = ({"comment": "会话-玩家关联表"},)
```

### 5.5 patients —— 褪色症患者

```python
# app/models/character.py

from sqlalchemy import String, Integer, Text, ForeignKey, JSON
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.models.base import Base, TimestampMixin, generate_uuid


class Patient(Base, TimestampMixin):
    """褪色症患者 —— 玩家角色"""
    __tablename__ = "patients"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    player_id: Mapped[str] = mapped_column(
        ForeignKey("players.id"), nullable=False
    )

    # ===== 公开层 =====
    name: Mapped[str] = mapped_column(
        String(64), nullable=False, comment="角色名"
    )
    gender: Mapped[str] = mapped_column(
        String(16), nullable=True, comment="性别"
    )
    age: Mapped[int] = mapped_column(
        Integer, nullable=True, comment="年龄"
    )
    former_identity: Mapped[str] = mapped_column(
        String(128), nullable=True, comment="原社会身份"
    )
    appearance: Mapped[str] = mapped_column(
        Text, nullable=True, comment="外貌描述 / 立绘描述"
    )

    # ===== 保密层 =====
    base_color: Mapped[str] = mapped_column(
        String(1), nullable=False, comment="灵魂底色: C/M/Y/K"
    )
    # CMYK 四色属性值
    cyan_value: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    magenta_value: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    yellow_value: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    key_value: Mapped[int] = mapped_column(Integer, default=1, nullable=False)

    # 人格档案（JSON 存储）
    personality_files: Mapped[dict] = mapped_column(
        JSON, nullable=True, comment='{"C": "蓝色档案文本", "M": "红色档案文本", ...}'
    )
    ideal_projection: Mapped[str] = mapped_column(
        Text, nullable=True, comment="理想投射 —— 最想成为的样子"
    )

    # 量子活性（HP）
    quantum_activity: Mapped[int] = mapped_column(
        Integer, default=10, nullable=False, comment="当前量子活性"
    )
    quantum_activity_max: Mapped[int] = mapped_column(
        Integer, default=10, nullable=False, comment="量子活性上限"
    )

    # 关系
    player: Mapped["Player"] = relationship(back_populates="patients")
    ghost: Mapped["Ghost"] = relationship(back_populates="patient", uselist=False)
    print_abilities: Mapped[list["PrintAbility"]] = relationship(
        back_populates="patient", foreign_keys="PrintAbility.patient_id"
    )

    __table_args__ = ({"comment": "褪色症患者表"},)
```

### 5.6 ghosts —— 电子幽灵

```python
# app/models/character.py（续）

class Ghost(Base, TimestampMixin):
    """电子幽灵 —— 由另一位玩家创造的伙伴实体"""
    __tablename__ = "ghosts"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    patient_id: Mapped[str] = mapped_column(
        ForeignKey("patients.id"), nullable=False, unique=True, comment="宿主患者 ID"
    )
    creator_player_id: Mapped[str] = mapped_column(
        ForeignKey("players.id"), nullable=False, comment="创造者玩家 ID"
    )

    # 公开层
    name: Mapped[str] = mapped_column(
        String(64), nullable=False, comment="幽灵名称"
    )
    appearance: Mapped[str] = mapped_column(
        Text, nullable=True, comment="外貌描述"
    )
    personality: Mapped[str] = mapped_column(
        Text, nullable=True, comment="初始性格描述"
    )

    # 颜色属性（继承患者底色，独立数值）
    base_color: Mapped[str] = mapped_column(
        String(1), nullable=False, comment="底色: C/M/Y/K"
    )

    # 关系
    patient: Mapped["Patient"] = relationship(back_populates="ghost")
    print_abilities: Mapped[list["PrintAbility"]] = relationship(
        back_populates="ghost", foreign_keys="PrintAbility.ghost_id"
    )

    __table_args__ = ({"comment": "电子幽灵表"},)
```

### 5.7 print_abilities —— 打印能力

```python
# app/models/ability.py

from sqlalchemy import String, Text, ForeignKey, Enum as SAEnum
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.models.base import Base, TimestampMixin, generate_uuid
import enum


class AbilityEffectType(str, enum.Enum):
    ATTACK = "attack"          # 攻击型（红色系）
    DEFENSE = "defense"        # 防御型（黑色系）
    CONTROL = "control"        # 控制型（蓝色系）
    RECOVERY = "recovery"      # 恢复/连接型（黄色系）
    SPECIAL = "special"        # 特殊型


class PrintAbility(Base, TimestampMixin):
    """打印能力 —— 幽灵保护宿主的超现实能力"""
    __tablename__ = "print_abilities"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    patient_id: Mapped[str] = mapped_column(
        ForeignKey("patients.id"), nullable=True, comment="持有该能力的患者（通过通信获得）"
    )
    ghost_id: Mapped[str] = mapped_column(
        ForeignKey("ghosts.id"), nullable=True, comment="原生持有该能力的幽灵"
    )
    name: Mapped[str] = mapped_column(
        String(64), nullable=False, comment="能力名称（如：倒流的雨）"
    )
    description: Mapped[str] = mapped_column(
        Text, nullable=False, comment="能力描述"
    )
    color: Mapped[str] = mapped_column(
        String(1), nullable=False, comment="关联颜色: C/M/Y/K"
    )
    effect_type: Mapped[AbilityEffectType] = mapped_column(
        SAEnum(AbilityEffectType), nullable=False, comment="效果类型"
    )

    # 关系
    patient: Mapped["Patient"] = relationship(
        back_populates="print_abilities", foreign_keys=[patient_id]
    )
    ghost: Mapped["Ghost"] = relationship(
        back_populates="print_abilities", foreign_keys=[ghost_id]
    )

    __table_args__ = ({"comment": "打印能力表"},)
```

### 5.8 timeline_events —— 时间线事件

```python
# app/models/timeline.py

from sqlalchemy import String, Text, Integer, ForeignKey, JSON, Enum as SAEnum
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.models.base import Base, TimestampMixin, generate_uuid
import enum


class EventType(str, enum.Enum):
    COMBAT = "combat"              # 战斗事件
    COMMUNICATION = "communication" # 通信事件
    EXPLORATION = "exploration"    # 探索事件
    SKILL_CHECK = "skill_check"    # 技能检定
    SCENE_CHANGE = "scene_change"  # 场景切换
    SYSTEM = "system"              # 系统事件（加入/离开等）
    NARRATIVE = "narrative"        # 叙事事件


class TimelineEvent(Base, TimestampMixin):
    """时间线事件 —— 世界中发生的一切"""
    __tablename__ = "timeline_events"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    session_id: Mapped[str] = mapped_column(
        ForeignKey("sessions.id"), nullable=False
    )
    sequence: Mapped[int] = mapped_column(
        Integer, nullable=False, comment="事件在 Session 内的序号"
    )
    event_type: Mapped[EventType] = mapped_column(
        SAEnum(EventType), nullable=False
    )
    chapter: Mapped[int] = mapped_column(
        Integer, default=1, nullable=False, comment="所属章节"
    )
    actor_id: Mapped[str] = mapped_column(
        String(32), nullable=True, comment="事件发起者 ID（Patient / NPC）"
    )
    target_id: Mapped[str] = mapped_column(
        String(32), nullable=True, comment="事件目标 ID"
    )
    payload: Mapped[dict] = mapped_column(
        JSON, nullable=False, comment="事件详细数据"
    )
    narration: Mapped[str] = mapped_column(
        Text, nullable=True, comment="LLM 生成的叙述文本"
    )

    # 关系
    session: Mapped["Session"] = relationship(back_populates="timeline_events")

    __table_args__ = ({"comment": "时间线事件表"},)
```

### 5.9 world_states —— 世界状态

```python
# app/models/world.py

from sqlalchemy import String, Integer, ForeignKey, JSON
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.models.base import Base, TimestampMixin, generate_uuid


class WorldState(Base, TimestampMixin):
    """世界状态快照 —— 记录某一时刻的世界状态"""
    __tablename__ = "world_states"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    session_id: Mapped[str] = mapped_column(
        ForeignKey("sessions.id"), nullable=False
    )
    chapter: Mapped[int] = mapped_column(
        Integer, nullable=False, comment="章节"
    )
    sector_name: Mapped[str] = mapped_column(
        String(64), nullable=True, comment="当前扇区名称"
    )
    state_data: Mapped[dict] = mapped_column(
        JSON, nullable=False, comment="世界状态数据（环境、NPC 状态等）"
    )
    event_sequence: Mapped[int] = mapped_column(
        Integer, nullable=False, comment="对应的最新事件序号"
    )

    # 关系
    session: Mapped["Session"] = relationship(back_populates="world_states")

    __table_args__ = ({"comment": "世界状态快照表"},)
```

### 5.10 color_fragments —— 颜色碎片

```python
# app/models/fragment.py

from sqlalchemy import String, Integer, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column
from app.models.base import Base, TimestampMixin, generate_uuid


class ColorFragment(Base, TimestampMixin):
    """颜色碎片 —— 通过战斗/探索获取的属性碎片"""
    __tablename__ = "color_fragments"

    id: Mapped[str] = mapped_column(
        String(32), primary_key=True, default=generate_uuid
    )
    session_id: Mapped[str] = mapped_column(
        ForeignKey("sessions.id"), nullable=False
    )
    patient_id: Mapped[str] = mapped_column(
        ForeignKey("patients.id"), nullable=False, comment="持有者"
    )
    color: Mapped[str] = mapped_column(
        String(1), nullable=False, comment="碎片颜色: C/M/Y/K"
    )
    amount: Mapped[int] = mapped_column(
        Integer, default=1, nullable=False, comment="碎片数量"
    )
    source_event_id: Mapped[str] = mapped_column(
        ForeignKey("timeline_events.id"), nullable=True, comment="来源事件 ID"
    )

    __table_args__ = ({"comment": "颜色碎片表"},)
```

---

## 6. Alembic 迁移配置

### 6.1 初始化

```bash
# 在项目根目录执行
alembic init migrations
```

### 6.2 env.py 配置要点

```python
# migrations/env.py

from app.models.base import Base
from app.models import player, session, character, ability, timeline, world, fragment
from app.infra.config import settings

# 设置 target_metadata
target_metadata = Base.metadata

# 使用配置中的 DATABASE_URL
config.set_main_option("sqlalchemy.url", settings.DATABASE_URL.replace("+aiosqlite", "").replace("+asyncpg", "+psycopg2"))
```

### 6.3 迁移工作流

```bash
# 生成迁移脚本
alembic revision --autogenerate -m "描述变更内容"

# 执行迁移
alembic upgrade head

# 回滚一步
alembic downgrade -1

# 查看当前版本
alembic current
```

### 6.4 命名规范

| 项目 | 规范 |
|------|------|
| 迁移消息 | 英文，简洁描述变更（如 `add quantum_activity to patients`） |
| 表名 | 复数小写（`players`, `sessions`） |
| 字段名 | 小写下划线（`base_color`, `quantum_activity`） |
| 外键命名 | `fk_{source_table}_{target_table}_{column}`（自动生成） |
| 索引命名 | `ix_{table}_{column}`（自动生成） |

---

## 7. Session 管理最佳实践

### 7.1 在 API 层使用

```python
# app/api/bot.py

from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.infra.db import get_db

router = APIRouter(prefix="/bot")


@router.post("/event")
async def handle_event(event: EventInput, db: AsyncSession = Depends(get_db)):
    # db Session 由依赖注入自动管理生命周期
    result = await dispatcher.dispatch(event, db=db)
    return result
```

### 7.2 在 Domain 层使用

```python
# domain 层接收 db session 作为参数，不自行创建

async def create_patient(db: AsyncSession, data: PatientCreate) -> Patient:
    patient = Patient(**data.model_dump())
    db.add(patient)
    await db.flush()  # flush 而非 commit，由 API 层统一 commit
    return patient
```

### 7.3 事务边界

| 原则 | 说明 |
|------|------|
| API 层管 commit | `get_db()` 中统一 commit / rollback |
| Domain 层用 flush | 保证同一请求内的后续查询可见 |
| 禁止嵌套事务 | 避免 `session.begin_nested()`，保持事务扁平化 |

---

## 8. 索引策略

```python
# 建议在以下字段上创建索引（通过 Alembic 迁移添加）

# players
Index("ix_players_platform_uid", "platform", "platform_user_id", unique=True)

# sessions
Index("ix_sessions_status", "status")

# timeline_events
Index("ix_timeline_session_seq", "session_id", "sequence")
Index("ix_timeline_event_type", "event_type")

# color_fragments
Index("ix_fragments_patient", "patient_id")
Index("ix_fragments_session", "session_id")
```

---

## 9. 测试策略

```python
# tests/conftest.py

import pytest_asyncio
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from app.models.base import Base


@pytest_asyncio.fixture
async def db_session():
    """每个测试用例使用独立的内存数据库"""
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    session_factory = async_sessionmaker(engine, class_=AsyncSession)
    async with session_factory() as session:
        yield session

    await engine.dispose()
```
