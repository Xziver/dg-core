# 05 — 玩家交互方式

> 本文档定义 dg-engine 与客户端之间的交互模型。
> 引擎不直接处理玩家自然语言，所有输入均为**结构化事件**。

---

## 1. 核心原则

```
玩家（人类）
    ↓ 自然语言 / 斜杠命令
客户端（Bot / Web / CLI）
    ↓ 解析 & 转换
结构化事件（Event）
    ↓ HTTP API
dg-engine（世界引擎）
    ↓ 处理 & 结算
结构化结果（Result）+ 可选叙述
    ↓ HTTP Response
客户端
    ↓ 格式化展示
玩家
```

### 1.1 职责划分

| 层 | 职责 | 不做的事 |
|----|------|---------|
| **客户端** | 解析玩家输入、转换为 Event、展示结果 | 不执行游戏逻辑、不修改世界状态 |
| **引擎** | 接收 Event、执行规则、更新状态、返回 Result | 不解析自然语言、不关心展示格式 |

### 1.2 为什么引擎不处理自然语言？

| 原因 | 说明 |
|------|------|
| 确定性 | 引擎是状态机，输入必须是明确的结构化数据 |
| 可测试 | 结构化 Event 可以精确构造，便于自动化测试 |
| 多端兼容 | 不同客户端（Discord Bot / Web / CLI）的输入方式不同 |
| 关注分离 | NLP 是客户端的责任，引擎只关心"发生了什么" |

---

## 2. 事件分类

### 2.1 事件总览

所有从客户端发送到引擎的事件，统一使用 `EngineEvent` 格式：

```python
class EngineEvent(BaseModel):
    """引擎事件 —— 客户端发往引擎的统一格式"""
    event_type: str                 # 事件类型标识
    session_id: str                 # 所属 Session
    player_id: str                  # 发起者 Player ID
    patient_id: str | None = None   # 关联的 Patient ID
    payload: dict                   # 事件具体数据
    timestamp: datetime             # 客户端时间戳
```

### 2.2 行动事件（Action Events）

玩家在世界中执行的主动行为。

| 事件类型 | payload 结构 | 说明 |
|---------|-------------|------|
| `action.explore` | `{"area_id": str, "description": str}` | 探索区域 |
| `action.interact` | `{"target_id": str, "interaction_type": str}` | 与物体/NPC 交互 |
| `action.skill_check` | `{"skill_color": str, "action_description": str}` | 发起技能检定 |
| `action.use_ability` | `{"ability_id": str, "target_id": str?}` | 使用打印能力 |
| `action.collect_fragment` | `{"fragment_source": str}` | 收集颜色碎片 |

```python
# 示例：玩家发起蓝色（认知）技能检定
event = EngineEvent(
    event_type="action.skill_check",
    session_id="sess_001",
    player_id="player_abc",
    patient_id="patient_xyz",
    payload={
        "skill_color": "C",
        "action_description": "尝试分析墙上的加密数据流",
    },
    timestamp=datetime.now(timezone.utc),
)
```

### 2.3 战斗事件（Combat Events）

战斗流程中的事件。

| 事件类型 | payload 结构 | 说明 |
|---------|-------------|------|
| `combat.attack` | `{"target_id": str, "attack_color": str}` | 发起攻击 |
| `combat.defend` | `{"defense_color": str}` | 宣言防御 |
| `combat.use_ability` | `{"ability_id": str, "target_id": str?}` | 战斗中使用打印能力 |
| `combat.flee` | `{}` | 尝试逃跑 |
| `combat.reroll` | `{"ability_id": str, "original_roll_id": str}` | 使用打印能力重投 |

```python
# 示例：玩家使用红色（力量）攻击
event = EngineEvent(
    event_type="combat.attack",
    session_id="sess_001",
    player_id="player_abc",
    patient_id="patient_xyz",
    payload={
        "target_id": "npc_monster_01",
        "attack_color": "M",
    },
    timestamp=datetime.now(timezone.utc),
)
```

### 2.4 通信事件（Communication Events）

玩家之间的数据交换。

| 事件类型 | payload 结构 | 说明 |
|---------|-------------|------|
| `comm.request` | `{"target_player_id": str, "color": str}` | 发起通信请求 |
| `comm.accept` | `{"request_id": str}` | 接受通信请求 |
| `comm.reject` | `{"request_id": str}` | 拒绝通信请求 |
| `comm.scan` | `{"target_patient_id": str, "scan_depth": str}` | 深层扫描（查看档案） |
| `comm.download_ability` | `{"source_ghost_id": str, "ability_id": str}` | 下载打印能力 |
| `comm.seize` | `{"target_ghost_id": str}` | 发动抢夺（夺回自己的幽灵） |

```python
# 示例：玩家请求与蓝色属性的另一玩家通信
event = EngineEvent(
    event_type="comm.request",
    session_id="sess_001",
    player_id="player_abc",
    patient_id="patient_xyz",
    payload={
        "target_player_id": "player_def",
        "color": "C",
    },
    timestamp=datetime.now(timezone.utc),
)
```

### 2.5 系统事件（System Events）

会话管理和系统级操作。

| 事件类型 | payload 结构 | 说明 |
|---------|-------------|------|
| `system.join_session` | `{"patient_id": str}` | 加入会话 |
| `system.leave_session` | `{}` | 离开会话 |
| `system.select_sector` | `{"sector_index": int}` | 选择扇区 |
| `system.dm_advance_chapter` | `{"chapter": int}` | DM 推进章节 |
| `system.dm_set_scene` | `{"scene_data": dict}` | DM 设置场景 |
| `system.query_status` | `{}` | 查询当前状态 |

---

## 3. 引擎响应格式

### 3.1 统一响应体

```python
class EngineResult(BaseModel):
    """引擎响应 —— 引擎返回给客户端的统一格式"""
    success: bool                   # 操作是否成功
    event_type: str                 # 原始事件类型
    session_id: str
    sequence: int                   # 事件在 timeline 中的序号

    # 结构化结果数据
    data: dict                      # 具体结果数据（骰子值、伤害、状态变更等）

    # 可选叙述
    narration: str | None = None    # LLM 生成的叙述文本

    # 状态变更摘要
    state_changes: list[StateChange] = []

    # 错误信息
    error: str | None = None


class StateChange(BaseModel):
    """状态变更记录"""
    entity_type: str                # "patient" | "ghost" | "world"
    entity_id: str
    field: str
    old_value: Any
    new_value: Any
```

### 3.2 响应示例

```json
{
    "success": true,
    "event_type": "action.skill_check",
    "session_id": "sess_001",
    "sequence": 42,
    "data": {
        "skill_color": "C",
        "dice_count": 2,
        "dice_values": [4, 6],
        "highest": 6,
        "threshold": 4,
        "passed": true,
        "can_reroll": true,
        "available_abilities": ["ability_001"]
    },
    "narration": "你伸出手，指尖轻触墙面上流淌的数据流。蓝色的光芒在你的认知信道中回荡——那些加密的符号在你眼中逐渐解构，化为可读的信息碎片。墙壁深处，一条隐藏的通道缓缓显形。",
    "state_changes": [],
    "error": null
}
```

---

## 4. 客户端职责详解

### 4.1 客户端必须做的事

```
1. 接收玩家输入（自然语言 / 命令 / UI 操作）
2. 解析输入，判断意图
3. 转换为 EngineEvent
4. 发送 HTTP 请求到引擎 API
5. 接收 EngineResult
6. 将结构化数据 + 叙述文本格式化为用户可读内容
7. 展示给玩家
```

### 4.2 客户端本地处理的命令

以下命令由客户端**本地处理**，不发送到引擎：

| 命令 | 说明 | 处理方式 |
|------|------|---------|
| `/roll NdM` | 投骰子（非检定） | 客户端本地随机生成并展示 |
| `/help` | 帮助信息 | 客户端本地展示帮助文本 |
| `/status` | 查看自己的状态 | 客户端缓存 + 本地展示（也可查询引擎刷新） |
| `/card` | 查看角色名片 | 客户端缓存 + 本地展示 |
| `/history` | 查看聊天历史 | 客户端本地功能 |

### 4.3 必须发送到引擎的命令

以下操作**影响世界状态**，必须转换为 Event 发送到引擎：

| 玩家行为 | 转换为事件 | 原因 |
|---------|-----------|------|
| "我攻击那个怪物" | `combat.attack` | 影响 HP、触发战斗结算 |
| "检查这面墙" | `action.skill_check` | 触发骰子检定、可能改变世界状态 |
| "我要和 XX 通信" | `comm.request` | 影响两个玩家的数据交换 |
| "使用【倒流的雨】" | `combat.use_ability` | 消耗能力使用次数、影响战斗 |
| "选择扇区 2" | `system.select_sector` | 改变玩家位置和世界状态 |

### 4.4 客户端输入解析示例

```python
# 客户端侧代码示例（非引擎代码）

def parse_player_input(raw_input: str, context: PlayerContext) -> EngineEvent | LocalCommand:
    """将玩家原始输入解析为引擎事件或本地命令"""

    # 本地命令
    if raw_input.startswith("/roll"):
        return LocalCommand(type="roll", args=raw_input[5:].strip())
    if raw_input.startswith("/help"):
        return LocalCommand(type="help")

    # 结构化命令 → 引擎事件
    if raw_input.startswith("/attack"):
        target = extract_target(raw_input)
        return EngineEvent(
            event_type="combat.attack",
            session_id=context.session_id,
            player_id=context.player_id,
            patient_id=context.patient_id,
            payload={"target_id": target, "attack_color": context.preferred_color},
            timestamp=datetime.now(timezone.utc),
        )

    if raw_input.startswith("/check"):
        color = extract_color(raw_input)
        desc = extract_description(raw_input)
        return EngineEvent(
            event_type="action.skill_check",
            session_id=context.session_id,
            player_id=context.player_id,
            patient_id=context.patient_id,
            payload={"skill_color": color, "action_description": desc},
            timestamp=datetime.now(timezone.utc),
        )

    # 自然语言 → NLP 解析（未来实现）
    # return nlp_parse(raw_input, context)

    raise UnknownCommandError(f"无法解析的输入: {raw_input}")
```

---

## 5. HTTP API 接口设计

### 5.1 事件提交端点

```python
# app/api/bot.py

from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.infra.db import get_db
from app.models.event import EngineEvent
from app.models.result import EngineResult
from app.domain.dispatcher import dispatch

router = APIRouter(prefix="/bot", tags=["bot"])


@router.post("/event", response_model=EngineResult)
async def handle_event(
    event: EngineEvent,
    db: AsyncSession = Depends(get_db),
) -> EngineResult:
    """
    接收客户端事件并处理。

    所有事件统一通过此端点提交，由 dispatcher 路由到对应的规则处理器。
    """
    return await dispatch(event, db=db)
```

### 5.2 状态查询端点

```python
# app/api/bot.py（续）

@router.get("/session/{session_id}/status")
async def get_session_status(
    session_id: str,
    db: AsyncSession = Depends(get_db),
):
    """查询会话状态（供客户端缓存刷新）"""
    ...

@router.get("/patient/{patient_id}/public")
async def get_patient_public(
    patient_id: str,
    db: AsyncSession = Depends(get_db),
):
    """获取患者公开信息（PUBLIC 文件）"""
    ...

@router.get("/patient/{patient_id}/full")
async def get_patient_full(
    patient_id: str,
    player_id: str,  # 用于权限校验
    db: AsyncSession = Depends(get_db),
):
    """获取患者完整信息（FULL 文件，需权限验证）"""
    ...
```

---

## 6. 事件处理流程

### 6.1 Dispatcher 路由

```python
# app/domain/dispatcher.py

from app.models.event import EngineEvent
from app.models.result import EngineResult


# 事件处理器注册表
EVENT_HANDLERS = {
    "action.skill_check": "app.domain.rules.skill.handle_skill_check",
    "action.explore": "app.domain.rules.exploration.handle_explore",
    "combat.attack": "app.domain.rules.combat.handle_attack",
    "combat.defend": "app.domain.rules.combat.handle_defend",
    "combat.reroll": "app.domain.rules.combat.handle_reroll",
    "comm.request": "app.domain.rules.communication.handle_comm_request",
    "comm.accept": "app.domain.rules.communication.handle_comm_accept",
    "comm.download_ability": "app.domain.rules.communication.handle_download_ability",
    "system.join_session": "app.domain.rules.session_mgmt.handle_join",
    "system.leave_session": "app.domain.rules.session_mgmt.handle_leave",
    "system.select_sector": "app.domain.rules.session_mgmt.handle_select_sector",
    # ...
}


async def dispatch(event: EngineEvent, db) -> EngineResult:
    """事件路由 —— 根据 event_type 分发到对应处理器"""
    handler_path = EVENT_HANDLERS.get(event.event_type)
    if not handler_path:
        return EngineResult(
            success=False,
            event_type=event.event_type,
            session_id=event.session_id,
            sequence=-1,
            data={},
            error=f"未知的事件类型: {event.event_type}",
        )

    handler = _import_handler(handler_path)
    return await handler(event, db=db)
```

### 6.2 完整处理链路

```
EngineEvent
    ↓
dispatcher.dispatch()           # 路由到对应 handler
    ↓
domain.rules.*.handle_*()      # 执行游戏规则
    ├── modules.dice.roller     # 投骰子
    ├── modules.rag.retriever   # 检索知识（可选）
    ├── modules.llm.client      # 生成叙述（可选）
    └── db session              # 读写数据库
    ↓
timeline.record()              # 记录时间线事件
    ↓
EngineResult                   # 返回结果
```

---

## 7. 错误处理

### 7.1 事件验证错误

```python
# 客户端发送了不合法的事件
{
    "success": false,
    "event_type": "combat.attack",
    "session_id": "sess_001",
    "sequence": -1,
    "data": {},
    "narration": null,
    "state_changes": [],
    "error": "患者 patient_xyz 不在活跃的战斗中"
}
```

### 7.2 常见错误码

| 错误场景 | error 内容 |
|---------|-----------|
| Session 不存在 | `"Session sess_xxx 不存在"` |
| Session 未激活 | `"Session sess_xxx 当前状态为 paused，无法处理事件"` |
| 玩家不在 Session 中 | `"玩家 player_xxx 未加入 Session sess_xxx"` |
| 非法的颜色代码 | `"无效的颜色代码: X，必须为 C/M/Y/K 之一"` |
| 能力已用尽 | `"打印能力 ability_xxx 本 Session 使用次数已耗尽"` |
| 通信条件不满足 | `"缺少 C 色属性，无法与目标通信"` |
| 量子活性归零 | `"患者 patient_xyz 量子活性已归零，触发幽体坍缩"` |
